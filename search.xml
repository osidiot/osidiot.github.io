<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Virtio硬件实现——0.95 reset问题</title>
      <link href="/2021/11/18/pci-non-post/"/>
      <url>/2021/11/18/pci-non-post/</url>
      
        <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>最近，在讨论如何在mlnx硬件卸载场景上支持virtio 0.95，因为virtio 0.95协议本身对硬件virtio直通不够友好，所以需要做些特殊的quirks处理。</p><p>面临最棘手的问题便是：virtio 0.95规范中对STATUS寄存器没有约定需同步等待，导致某些较老版本的virtio legacy驱动无法支持。举例来说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vp_reset</span><span class="params">(struct virtio_device *vdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_device</span> *<span class="title">vp_dev</span> =</span> to_vp_device(vdev);</span><br><span class="line"><span class="comment">/* 0 status means a reset. */</span></span><br><span class="line">iowrite8(<span class="number">0</span>, vp_dev-&gt;ioaddr + VIRTIO_PCI_STATUS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述为Linux 2.6.39中virtio legacy驱动的实现，可见：<strong>在reset设备时，将STATUS清零后直接返回</strong>。</p><p>在QEMU模拟virtio场景下，此方式无问题，因为iowrite将引起陷出，最终由QEMU进行相应reset操作。</p><p>但是在硬件virtio VF直通场景下，cpu下发完reset请求后，VF硬件可能还没有处理完成，cpu便可继续执行后续操作，这便存在潜在风险：后续操作的正确性可能依赖于VF硬件已经reset完成，而彼时VF硬件可能尚在reset过程中（e.g. <strong>后续运行过程中读取STATUS时，可能STATUS寄存器依然不为零</strong>）。</p><p>&nbsp;</p><h3 id="关键分析"><a href="#关键分析" class="headerlink" title="关键分析"></a>关键分析</h3><h4 id="cpu通过iowrite操作PCIe设备能否阻塞cpu？"><a href="#cpu通过iowrite操作PCIe设备能否阻塞cpu？" class="headerlink" title="cpu通过iowrite操作PCIe设备能否阻塞cpu？"></a>cpu通过iowrite操作PCIe设备能否阻塞cpu？</h4><p>在linux内核中，iowrite实际上有pio、mmio两种具体实现方式，首先需要明白我们场景中使用的是哪一种！</p><p>我们通过SR-IOV + vfio-pci直通方式将virtio VF直通给虚拟机，SR-IOV规范有个限制：<strong>VF只支持memory BAR、不支持io BAR，因此对其访问只能是以mmio方式</strong>。</p><p>说下答案：<strong>不能!!!!</strong></p><p>如果mmio能够阻塞就好了，就能够在设备reset完成后再让cpu继续执行下去，我们就不会遇到上面的问题了。</p><p>那么，为什么不能呢？</p><p>mmio write属于“Memory write”操作。在PCIe体系中，Memory write属于<strong>Posted Transactions</strong>，requester（此处即cpu）不需要等待completion TLP，可以立刻去干别的事情，类似导弹技术中的“发射后不管”。</p><p>&nbsp;</p><h4 id="较新的virtio-legacy驱动是否有同步？"><a href="#较新的virtio-legacy驱动是否有同步？" class="headerlink" title="较新的virtio legacy驱动是否有同步？"></a>较新的virtio legacy驱动是否有同步？</h4><p>来看一下Linux 5.12中virtio legacy驱动的相关实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vp_reset</span><span class="params">(struct virtio_device *vdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_device</span> *<span class="title">vp_dev</span> =</span> to_vp_device(vdev);</span><br><span class="line"><span class="comment">/* 0 status means a reset. */</span></span><br><span class="line">iowrite8(<span class="number">0</span>, vp_dev-&gt;ioaddr + VIRTIO_PCI_STATUS);</span><br><span class="line"><span class="comment">/* Flush out the status write, and flush in device writes,</span></span><br><span class="line"><span class="comment"> * including MSi-X interrupts, if any. */</span></span><br><span class="line">ioread8(vp_dev-&gt;ioaddr + VIRTIO_PCI_STATUS);</span><br><span class="line"><span class="comment">/* Flush pending VQ/configuration callbacks. */</span></span><br><span class="line">vp_synchronize_vectors(vdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到：在reset之后，多了一个ioread的动作。根据注释，此处ioread的原因并不是为了和底层硬件进行同步，而仅仅是为了确保上面的iowrite操作能够flush out或者设备的写操作能够flush in，主要是站在cpu角度进行内存屏障之类的处理。</p><p>但是，<strong>这却为硬件virtio 0.95实现创造了一个机会，可以利用ioread做文章</strong>。</p><p>ioread在我们分析的场景中是mmio read，属于“Memory read”操作，此类请求属于<strong>Non-posted Transactions</strong>，意味着requester（此处即cpu）需要等待PCIe硬件回复completion TLP方可继续。如此一来，便可以借机实现“伪同步”的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    cpu -&gt;&gt; + Virtio VF : iowrite STATUS-&gt;0</span><br><span class="line">    Virtio VF -&gt;&gt; Virtio VF : starting reset</span><br><span class="line">    cpu -&gt;&gt; + Virtio VF : ioread STATUS</span><br><span class="line">    cpu -&gt;&gt; cpu : wait for Read completion TLP</span><br><span class="line">    Virtio VF -&gt;&gt; Virtio VF : finish reset</span><br><span class="line">    Virtio VF -&gt;&gt;  cpu : reply Read completion TLP</span><br><span class="line">    cpu -&gt;&gt; cpu : continue</span><br></pre></td></tr></table></figure><p>可以看到：只要Virtio VF硬件中控制好在reset处理完成后才能处理后续请求（即读请求），便能够实现“同步”的效果。</p><p>&nbsp;</p><h4 id="virtio-modern驱动能够实现同步？"><a href="#virtio-modern驱动能够实现同步？" class="headerlink" title="virtio modern驱动能够实现同步？"></a>virtio modern驱动能够实现同步？</h4><p>来看一下Linux 5.12中virtio modern（ &gt;= virtio 1.0）驱动的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vp_reset</span><span class="params">(struct virtio_device *vdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_device</span> *<span class="title">vp_dev</span> =</span> to_vp_device(vdev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_modern_device</span> *<span class="title">mdev</span> =</span> &amp;vp_dev-&gt;mdev;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0 status means a reset. */</span></span><br><span class="line">vp_modern_set_status(mdev, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* After writing 0 to device_status, the driver MUST wait for a read of</span></span><br><span class="line"><span class="comment"> * device_status to return 0 before reinitializing the device.</span></span><br><span class="line"><span class="comment"> * This will flush out the status write, and flush in device writes,</span></span><br><span class="line"><span class="comment"> * including MSI-X interrupts, if any.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span> (vp_modern_get_status(mdev))</span><br><span class="line">msleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* Flush pending VQ/configuration callbacks. */</span></span><br><span class="line">vp_synchronize_vectors(vdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vp_modern_get_status - get the device status</span></span><br><span class="line"><span class="comment"> * @mdev: the modern virtio-pci device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the status read from device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u8 <span class="title">vp_modern_get_status</span><span class="params">(struct virtio_pci_modern_device *mdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci_common_cfg</span> __<span class="title">iomem</span> *<span class="title">cfg</span> =</span> mdev-&gt;common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vp_ioread8(&amp;cfg-&gt;device_status);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(vp_modern_get_status);</span><br></pre></td></tr></table></figure><p>可以看到：驱动将主动等待STATUS变为0。<strong>当然，Virtio设备需要在reset操作处理完成后，才将STATUS复位成0</strong>。</p><p>个人认为，此种驱动实现方式对硬件（virtio VF、cpu）更加友好：</p><ul><li>“较新的virtio legacy驱动”需要Virtio VF硬件中实现：read STATUS操作需要等到reset操作结束后才能回复completion TLP，增加了硬件内部实现的复杂度；而“virtio modern驱动”不需要VF硬件做类似保障，reset操作与read STATUS操作是解耦的，无内在牵连。</li><li>如果reset操作耗时较久，“较新的virtio legacy驱动”将导致cpu一直处于等待read STATUS响应的状态；而“virtio modern驱动”可以通过msleep主动触发任务调度。</li></ul><p>&nbsp;</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>]]></content>
      
      
      <categories>
          
          <category> virtio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtio </tag>
            
            <tag> pcie </tag>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2021/11/14/Test/"/>
      <url>/2021/11/14/Test/</url>
      
        <content type="html"><![CDATA[<h3 id="Haaaaaa"><a href="#Haaaaaa" class="headerlink" title="Haaaaaa"></a>Haaaaaa</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/14/hello-world/"/>
      <url>/2021/11/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
